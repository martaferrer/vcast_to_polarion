# This module defines a PolarionGateway Python class which is used by the
# VectorCAST Requirements Gateway to interact with Polarion.
#
# Do not edit this file directly, as it might be overwritten by future
# installations of VectorCAST. Instead, save a copy in this directory and edit
# the copy for your custom use. The modified file can then be specified in the
# Requirements Gateway options.

scriptRootVersion = '1.4'    # Please don't change the script root version

# Specify your login information for the Polarion web server on the Options TAB
# - Polarion server
#     Specify the path to the Polarion web service. Examples of valid pathes are:
#     Polarion ALM demo web server: http://almdemo.polarion.com/polarion/ws/services/
#     Example for a local Polarion server installation: http://your_computer/polarion/ws/services/
# - Polarion user, Polarion password:
#     You may want to create a seperate user for VectorCAST
# - Project ID
#     Specify the project ID of your existing Polarion project
#     Example: My_Project
# - Polarion tesRunID
#     When you export data to Polarion VectorCAST will create a test record for each test case in a Polarion test run.
#     Specify here the name of the Polarion test run. If unavailable the test run will be created
#     Example: My_TestRun

# **********************************************
# **********************************************
# ***               Custom                   ***
# ***        configuration section           ***
# ***               begin                    ***
# **********************************************
# **********************************************

# Query string to get Requirements from Polarion. Examples for valid query strings are:
# requirementsQueryString = 'type:requirement AND (status:accepted OR status:completed)'
# requirementsQueryString = 'type:requirement AND status:(accepted active approved draft) AND author.id:$[user.id]'
# You can compose your requirements query string in the Polarion work items view and copy it to this script
requirementsQueryString = 'type:(softwareRequirement systemRequirement requirement)'

# Polarion only knows the statuses 'passed', 'failed' and 'blocked'; but VectorCAST also has the additional test case status 'none'.
# Since 'none' is the result for a test case execution that has no expected values it is most likely a stress test. In that case
# the none-failing of the test case is meant to be a pass. This flag allows you to treat test cases with execution result 'none'
# as passed test cases and export them to the Polarion test run. If you set this flag to False we will not export test cases with execution
# result 'none' to the Polarion test run. Note: If unavailable the test case will be created in Polarion, independent of this flag
# treatTestCaseResultNoneAsPassed = True

# When you export data to Polarion VectorCAST will search in Polarion for the test case name and create a new work
# item if the test case is not found. It is essential that the test case names exported to Polarion are unique. Therefore it
# is highly recommended to construct the test case name for Polarion as "Environment name" + "::" + "test case name".
# However, you can create test cases in Polarion using the test case name only by setting this flag to False
# prependEnvToTestCaseName = True

# You can chose to automatically append a date and time string to the test run ID
# so that for each export a new test run is created in Polarion automatically
appendTimeToTestRunID = False

# Predefined settings for test case creation in Polarion
# testCaseType         = 'testcase'
testCaseTestType     = 'Automated Test'
testCaseSeverity     = 'Basic'
testCaseStatus       = 'Draft'
testCaseResultPassed = 'passed'
testCaseResultFailed = 'failed'

# Script settings
scriptVersion = '1.0'   # Use this variable for your versioning.

currentTraceLevel = 1     # 0: No Traces, 1: Normal, ..., 6 Exhaustive

cacheDays = 1
cacheDir=''             # You may want to specify a specific cache directory for the WSDL services. E.g. 'C:\VCAST\cache'

# **********************************************
# **********************************************
# ***               Custom                   ***
# ***        configuration section           ***
# ***                end                     ***
# **********************************************
# **********************************************

# Root Version Change History
# 1.0 Alpha version
#     Date 23-NOV-2012
#     Author IHN
# 1.1 GUI support VC61 Options TAB
#     Date 08-DEC-2012
#     Author IHN
# 1.2 New _assign_utf8() to handle UTF-8 UnicodeEncodeError
#     New flag appendTimeToTestRunID
#     Date 26-MAR-2013
#     Author IHN
# 1.3 Added support for requirements with no test cases assigned
#     Date 25-APR-2013
#     Author IHN
# 1.4 Reworked for Distalmotion
#     Date 05-JAN-2021
#     Author Marta Ferrer

scriptVersionString = "R" + scriptRootVersion + "V" + scriptVersion

import base_gateway
import codecs
import xml.etree.ElementTree as xml


import suds
import logging
import time
import re
import pandas as pd
from tabulate import tabulate

from suds.client import Client
from suds.sax.element import Element
from suds.sax.attribute import Attribute
from suds.plugin import MessagePlugin
from suds.cache import ObjectCache
from time import gmtime, strftime

# Set up Polarion WDSL namespaces.

nsCoreTypes = "{http://ws.polarion.com/types}"
nsTrackerTypes = "{http://ws.polarion.com/TrackerWebService-types}"
nsTestManagementTypes = "{http://ws.polarion.com/TestManagementWebService-types}"

# Hard coded combo values.

idAttr    = 'WorkItem-ID'
titleAttr = 'Title'
descAttr  = 'Description'
wiUriAttr = 'WorkItem-Uri'

businessWorkItemType = 'businesscase'
reqWorkItemType = 'requirement'
testcaseWorkItemType = 'testcase'
taskWorkItemType = 'task'
changeReqWorkItemType = 'changerequest'
defectWorkItemType = 'defect'
riskWorkItemType = 'risk'

class PolarionTestManagementFixer(MessagePlugin):
   def marshalled(self, context):
        #remove empty tags inside the Body element
        #context.envelope[0] is the SOAP-ENV:Header element
        #This Plugin is necessary because there is a bug in the Polarion testManagement WSDL
        #that doesn't allow empty attributes
       if currentTraceLevel >= 4:
           print ("PolarionTestManagementFixer Before:"+str(context.envelope))
       context.envelope[1].prune()
       if currentTraceLevel >= 4:
           print ("PolarionTestManagementFixer  After:"+str(context.envelope))

class PolarionGateway(base_gateway.BaseGateway):
    def __init__(self, **settings):
        base_gateway.BaseGateway.__init__(self)
        self.trace_buffer = ''
        self.trace_to_stdout = True

        # Create client to Polarion
        self.ocProject = ObjectCache()
        self.ocTracker = ObjectCache()
        self.ocTestManagement = ObjectCache()
        self.ocSession = ObjectCache()

        self.project = None
        self.tracker = None
        self.testManagement = None
        self.session = None

        # Firmware under test
        self.firmwareUnderTest = settings['firmwareUT']
        self.PolarionDocument = settings['documentPolarion']
        self.SwVersion = settings["softwareVersion"]
        self.testRunID = self.firmwareUnderTest + 'Unit Test Sw Version ' + self.SwVersion
        self.queryRefinement = ''

        # Polarion settings
        self.username = ''
        self.password = ''
        self.polarionWebServer = ''
        self.projectID = ''
        self.workItemType = 'softwareUnitTest'
        self.testCaseType = 'softwareUnitTest'
        self.treatTestCaseResultNoneAsPassed = True
        self.prependEnvToTestCaseName = True

        # Export requirements list
        self.export_data = {}
        self.tc_export_data = {}

        logging.basicConfig()
        if currentTraceLevel >= 6:
            logging.getLogger('suds').setLevel(logging.DEBUG)
        else:
            logging.getLogger('suds').setLevel(logging.ERROR)


    def _createClients(self):
        self._trace ("Creating clients to access Polarion", 1)

        # self.get_all_list_data()

        # Init project Client
        self._trace ("Creating project client", 2)
        self.ocProject.setduration(days=cacheDays)
        self.ocProject.setlocation(cacheDir)
        self.project   = Client(self.polarionWebServer+'ProjectWebService?wsdl', cache=self.ocProject)
        self._trace ("project client: " + str(self.project), 5)

        # Init tracker Client
        self._trace("Creating tracker client", 2)
        self.ocTracker.setduration(days=cacheDays)
        self.ocTracker.setlocation(cacheDir)
        self.tracker   = Client(self.polarionWebServer+'TrackerWebService?wsdl', cache=self.ocTracker)
        self._trace("tracker client: " + str(self.tracker), 5)

        # Init testManagement Client
        self.ocTestManagement.setduration(days=cacheDays)
        self.ocTestManagement.setlocation(cacheDir)
        self._trace("Creating testManagement client", 2)
        self.testManagement   = Client(self.polarionWebServer+'TestManagementWebService?wsdl',
                                       plugins=[PolarionTestManagementFixer()], cache=self.ocTestManagement)
        self._trace("testManagement client: " + str(self.testManagement), 5)

        # Init session Client
        self._trace("Creating session client", 2)
        self.ocSession.setduration(days=cacheDays)
        self.ocSession.setlocation(cacheDir)
        self.session = Client(self.polarionWebServer +'SessionWebService?wsdl', cache=self.ocSession)
        self._trace("session client: " + str(self.session), 5)

        self._trace ("Clients created", 1)

    def is_running(self):
        # This module never does background work.
        return False

    def _trace(self, msg, lvl):
        # Record trace data to be shown to the user.
        if lvl <= currentTraceLevel:
            useTimestampOnTraceMessages = False
            if useTimestampOnTraceMessages:
                now = time.time()
                localtime = time.localtime(now)
                milliseconds = '%03d' % int((now - int(now)) * 1000)
                stamp = time.strftime('%Y%m%d%H%M%S', localtime) + milliseconds
                msg = stamp + "::" + msg.encode('ascii','replace')
            #print msg
            self.trace_buffer += msg
            self.trace_buffer += '\n'
            if self.trace_to_stdout:
                print(msg)
		
    def _set_error_trace(self, msg):
        self._trace (msg, 1)
        self._set_error (msg)

    def read_trace_log(self):
        # Return the trace data.
        return_trace = self.trace_buffer
        self.trace_buffer = ''
        return (True, return_trace)

    def cli_interactive_config(self, db_path, profile_name, mode):
        # Prompt for all required connection settings.
        result = False;
        if (mode == "connect"):
            self._cli_prompt_setting("Polarion server URL:", "server")
            self._cli_prompt_setting("Polarion Project ID:", "project_id")
            self._cli_prompt_setting("Polarion user:", "user")
            self._cli_prompt_setting("Polarion password:", "password")
            result = True
        elif (mode == "import"):
            self._cli_prompt_setting("Work Item Type:", "polarion_import_work_item_type")
            # Default.
            if "polarion_query_refinement" not in self.settings:
                self.settings[
                    "polarion_query_refinement"] = "status:(accepted active approved draft) AND author.id:$[user.id]"
            self._cli_prompt_setting("Query refinement:", "polarion_query_refinement")
            self._cli_prompt_setting("Title attribute field:", "title_attribute")
            self._cli_prompt_setting("Descrption attribute field:", "description_attribute")
            result = True
        elif (mode == "export"):
            self._cli_prompt_setting("Test run id:", "polarion_test_run_id")
            self._cli_prompt_setting("Create new test cases as Work Item type:", "polarion_export_work_item_type")
            self._cli_prompt_setting("Export test case name to Work Item attribute:", "polarion_work_item_attribute")
            self._cli_prompt_setting_bool("Create test result 'none' as passed?", "polarion_test_case_none_as_passed")
            self._cli_prompt_setting_bool("Prepend Environment name to test case name?",
                                          "polarion_prepend_environment_name")
            result = True
        else:
            self._trace("Please specify a valid interactive configuration mode.")
            self._trace("Valid modes are 'connect', 'import', 'export'.")
            result = False
        if (result):
            self._cli_persist_settings(db_path)
        return result

    def config_test(self, mode):
        # Check that the configuration is correct to perform the action specified in mode.
        allOK = True
        if (mode == "connect"):
            allOK = self._cli_check_setting("server") & allOK
            allOK = self._cli_check_setting("project_id") & allOK
            allOK = self._cli_check_setting("user") & allOK
            allOK = self._cli_check_setting("password") & allOK
            if (not allOK): return False
            # Perform connection test.
            if not self.login_to_polarion(): return False
            self._logout_from_polarion()
            return True
        elif (mode == "import"):
            # Check import fields.
            allOK = self._cli_check_setting("polarion_import_work_item_type") & allOK
            allOK = self._cli_check_setting("polarion_query_refinement") & allOK
            allOK = self._cli_check_setting("title_attribute") & allOK
            allOK = self._cli_check_setting("description_attribute") & allOK
            return allOK
        elif (mode == "export"):
            # Check export fields.
            allOK = self._cli_check_setting("polarion_test_run_id") & allOK
            allOK = self._cli_check_setting("polarion_export_work_item_type") & allOK
            allOK = self._cli_check_setting("polarion_work_item_attribute") & allOK
            allOK = self._cli_check_setting("polarion_prepend_environment_name") & allOK
            allOK = self._cli_check_setting("polarion_test_case_none_as_passed") & allOK
            return allOK
        else:
            self._trace("Please specify a valid configuration test mode.")
            self._trace("Valid modes are 'connect', 'import', 'export'.")
            return False

    def abort(self):
        # This module never does background work, so there is nothing to abort.
        return True

    def get_valid_attributes(self):
        # get_all_list_data now overrides.
        return (True, [])

    def get_list_data(self, listKey):
        if (listKey in self.dictionaryList.keys()):
            return (True, self.dictionaryList[listKey])
        else:
            return (False, [])

    def _get_list_data_hardcoded(self):
        attributesList = [idAttr, titleAttr, descAttr, wiUriAttr]
        workItemTypeList = [businessWorkItemType, reqWorkItemType, testcaseWorkItemType, taskWorkItemType,
                            changeReqWorkItemType, defectWorkItemType, riskWorkItemType]

        # For get_list_data
        self.dictionaryList = {'attributes': attributesList, 'work_item_types': workItemTypeList}

        # For get_all_list_data
        attributesListWithKey = ['attributes', attributesList]
        workItemTypeListWithKey = ['work_item_types', workItemTypeList]
        self.fullList = [attributesListWithKey] + [workItemTypeListWithKey]
        return True

    def _get_list_data_from_server(self):
        # Login.
        if not self.login_to_polarion():
            return False

        # Attributes still hard coded.
        attributesList = [idAttr, titleAttr, descAttr, wiUriAttr]

        # Work item types
        workItemTypeList = []
        for currWorkItemType in (self.tracker.service.getAllEnumOptionsForKey(self.projectID, "type")):
            workItemTypeList += [currWorkItemType.id]

        # Test Run Template Types
        testRunTemplateTypeList = []
        for currTestRunTemplateType in (self.testManagement.service.searchTestRunTemplates(self.projectID, 'id')):
            testRunTemplateTypeList += [currTestRunTemplateType.id]

        # Logout
        self._logout_from_polarion()

        # For get_list_data
        self.dictionaryList = {'attributes': attributesList, 'work_item_types': workItemTypeList,
                               'testrun_template_types': testRunTemplateTypeList}

        # For get_all_list_data
        attributesListWithKey = ['attributes', attributesList]
        workItemTypeListWithKey = ['work_item_types', workItemTypeList]
        testRunTemplateTypeListWithKey = ['testrun_template_types', testRunTemplateTypeList]
        self.fullList = [attributesListWithKey] + [workItemTypeListWithKey] + [testRunTemplateTypeListWithKey]
        return True

    def _assign_utf8 (self, textString):
        # Converts and returns given text into UTF-8 decoded string.
        # First eliminate character that hit the byte order mark (BOM) to avoid UnicodeEncodeError
        # BOM-characters are replaced by '?'. If you prefer to remove them change 'replace' to 'ignore' in textString.encode()
        self._trace ('UTF-8 String conversion from ' + textString, 4)
        toStr = textString.encode('ascii','replace')
        toStr = toStr.decode('utf-8')
        self._trace ('UTF-8 String conversion to ' + toStr, 4)
        return toStr

    def _write_requirement_data(self, item, out_file):
        # Get Req ID. Always available
        key = item.id
        # Get Req title. Deal with empty title
        if hasattr(item, 'title'):
            title = item.title
            title_str = item.title
            if len(title_str) > 50:
                title_str = title_str[:47] + '...'
        else:
            title = '<EMPTY>'
            title_str = title
        # Get Req description. Deal with empty description
        if hasattr(item, 'description'):
            r = re.compile('<br>')
            description = r.sub('\n', item.description.content)  #Change <br> to new line string: '\n'
            r = re.compile('<[^>]*>')
            description = r.sub('', description)                 #Remove all other html format tags
        else:
            description = '<EMPTY>'#.decode('utf-8')

        self._trace('Recording data for requirement ' + key + ', ' + title_str, 2)
        req_element = xml.Element('requirement')
        req_key_element = xml.SubElement(req_element, 'key')
        req_key_element.text = self._assign_utf8(key)
        req_id_element = xml.SubElement(req_element, 'id')
        req_id_element.text = self._assign_utf8(key)
        req_title_element = xml.SubElement(req_element, 'title')
        req_title_element.text = self._assign_utf8(title)
        req_description_element = xml.SubElement(req_element, 'description')
        req_description_element.text = description
        #self._trace( xml.tostring(req_element), 3)
        out_file.write('    ' + str(xml.tostring(req_element)) + '\n')

    def _login_to_polarion(self):

        self._trace("Loging to Polarion..", 1)

        # Create clients
        self._createClients()

        # Login to Polarion and prepare clients headers using the login response
        try:
            self.session.service.logIn(self.username, self.password)
        except Exception as e:
            self._set_error_trace("Unable to login to Polarion web server: " + str(e))
            return False

        # parse sessionID from the login response envelope and format header
        try:
            login_response = self.session.last_received()
        except Exception as e:
            self._set_error_trace("Exception in last_received(): " + str(e))
            return False

        try:
            ssnid = login_response.getChild("soapenv:Envelope").getChild("soapenv:Header").getChild("ns1:sessionID").getText()
        except Exception as e:
            self._set_error_trace("Exception in ssnid computing: " + str(e))
            return False
        sid = Element('sessionID', ns=('ns1','http://ws.polarion.com/session')).setText(ssnid)
        must_understand = Attribute("SOAP-ENV:mustUnderstand", "0")
        actor = Attribute("SOAP-ENV:actor", "http://schemas.xmlsoap.org/soap/actor/next")
        sid.append(must_understand)
        sid.append(actor)

        # set SOAP header
        self.tracker.set_options(soapheaders=sid)
        self.session.set_options(soapheaders=sid)
        self.testManagement.set_options(soapheaders=sid)
        self.project.set_options(soapheaders=sid)

        self._trace ('SOAP connection established successfully', 1)
        return True


    def _logout_from_polarion (self):
        try:
            self.session.service.endSession()
        except Exception as e:
            self._set_error_trace("Exception in endSession: " + str(e))
        self._trace ('SOAP connection finished successfully', 1)

    def _checkAttributeMapping(self):
        diagString = "This Python script currently only supports the mapping of "
        if self.settings.get('title_attribute', '') != titleAttr:
            self._set_error_trace(diagString + "Title attribute to " + str(titleAttr))
            return False
        if self.settings.get('description_attribute', '') != descAttr:
            self._set_error_trace(diagString + "Description attribute to " + str(descAttr))
            return False
        return True

    def start_fetch(self, requirementsTable):

        # Login and prepare clients headers
        if not self._login_to_polarion():
            return False

        # Select Work Item Type.
        if ( self.workItemType == ''):
            reqQueryString = 'project.id:' + self.projectID + ' AND ' + requirementsQueryString
        else:
            reqQueryString = 'project.id:' + self.projectID + ' AND type:(' + self.workItemType +')'

        # Add the document ID as a query
        reqQueryString += ' AND document.id:(' + self.PolarionDocument +')'

        # get a Python list with all requirements from Polarion
        sortString = 'id'
        fieldsarray = ['id','title','description','status']
        self._trace ("Requirements query string: " + reqQueryString, 3)
        try:
            reqString = self.tracker.service.queryWorkItems(reqQueryString, sortString, fieldsarray)
        except Exception as e:
            self._set_error_trace("Exception in queryWorkItems: " + str(e))
            return False

        for singleReq in reqString:
            requirementsTable = requirementsTable.append({'UnitTest': singleReq.title, 'KeyRequirement': singleReq.id}, ignore_index=True)

        if len(reqString) > 0:
            self._trace (str(len(reqString)) + " requirements imported.", 1)
        else:
            self._set_error_trace("No requirement imported. You may want to check the validity of the specified projectID: " + self.projectID + " and the specified reqQueryString: " + reqQueryString)

        return len(reqString) > 0, requirementsTable


    def finish_fetch(self):
        # Finish retrieving requirements information from external subsystem.
        # Return whether the retrieval was successful.

        self._logout_from_polarion()

        return True


    def finish_fetch(self):
        # Finish retrieving requirements information from external subsystem.
        # Return whether the retrieval was successful.

        self._logout_from_polarion()

        return True

    def is_export_supported(self):
        # Return whether test data can be exported using this module.
        return True

    def is_tc_data_export_supported(self):
        # Return whether test case driven test data can be exported using this module.
        return True

    # def add_data_for_export(self, **req_data):
    #     # Add test data (req_data) for a single requirement to be exported once
    #     # start_export is called.  Return whether the data was added
    #     # successfully.
    #     try:
    #         key = req_data.get('key', None)
    #         self.export_data[key] = req_data
    #         return True
    #     except Exception as e:
    #         self._set_error_trace("Exception in add_data_for_export: " + str(e))
    #     return False
        
    def add_testcase_data_for_export(self, **tc_data):
        # Add testcase-keyed test data (tc_data) for a single test case to be exported once
        # start_export is called.
        try:
            # Convert the newline delimited string of requirements to a python dict.
            tc_name = tc_data.get("test_name", "")
            tc_req_keys = tc_data.get("test_req_keys", "")
            tc_unique_id = tc_data.get("test_unique_id", "")
            list_req_keys = []
            dic_req_links = {}
            if tc_req_keys != "":
                list_req_keys = tc_req_keys.split('\n')
            for req_key_curr in list_req_keys:
                # Set up the requirement link.
                dic_req_links[req_key_curr] = {}
                dic_req_link_curr = dic_req_links[req_key_curr]
                dic_req_link_curr["req_key"] = req_key_curr
                dic_req_link_curr["req_id"] = self.export_data[req_key_curr]["id"]
            # Overwrite
            tc_data["test_req_keys"] = dic_req_links
            # Add to dictionary. Key is unique ID.
            self.tc_export_data[tc_unique_id] = tc_data
            return True
        except Exception as e:
            self._set_error("Exception in add_testcase_data_for_export: " + str(e))
        return False

    def _add_testRecord (self, trUri, tcUri, tcResult, userUri):
        # Adds a test record to the test run
        self._trace ("Adding test record to test run", 3)

        result = ''  #if tcResult = 'none' we keep init value in result
        if tcResult == 'pass':
           result = testCaseResultPassed
        else:
           if tcResult == 'fail':
               result = testCaseResultFailed
           else:
               if self.treatTestCaseResultNoneAsPassed:
                   result = testCaseResultPassed
               else:
                   self._trace("Test execution result 'none' can not be exported to Polarion. 'None' shall not be treated as 'passed'. Test case execution result not added to test run.", 2)
                   return
        self._trace ("Test case execution result mapped: " + str(tcResult) + " -> " + str(result), 2)

        newComment = self.testManagement.factory.create(nsCoreTypes + "Text")
        newComment.type = 'text/plain'
        newComment.content = 'Test record exported from VectorCAST'
        newComment.contentLossy = False

        executedTime = strftime("%Y-%m-%dT%H:%M:%S.000000+00:00", gmtime())
        self._trace ("executed time :" + str(executedTime), 3)

        try:
            addTRResult = self.testManagement.service.addTestRecord (trUri, tcUri, result, newComment, userUri._uri, executedTime)
            self._trace ("TestRecord successfully created. Result :" + str(addTRResult), 4)
        except Exception as e:
            self._set_error_trace("Exception in addTestResult: " + str(e))


    def _add_linkItem (self, reqWi, tcWiUri):
        # Checks if linkage between requirement workItem (reqWi) and test case workItem (tcWiUri = Uri of WorkItem) already exists
        # Adds the linkage (verifies/is verified by) if not existent yet
        # Note: If we add the link a second time it shows up twice inside Polarion so we need to verify that link is not there
        # Note: We don't need to update the reqWi afterwards because the same test case will never be added again to the same req.
        role_id = 'verifies'
        self._trace ("reqWi before addingLink " + str(reqWi), 4)

        # Return if Requirement not available in Polarion
        if reqWi._unresolvable:
            self._trace ("Requirement WorkItem unresolvable. Link to test case can not be added", 3)
            return

        # Check if test case URI is avalable in requirements linkedWorkItemsDerived list
        #if len(reqWi.linkedWorkItemsDerived) > 0:
            #for linkedWorkItem in reqWi.linkedWorkItemsDerived[0]:
                #self._trace ("linkedWorkItem: " + str(linkedWorkItem), 4)
                #if linkedWorkItem.workItemURI == tcWiUri:
                    #if linkedWorkItem.role.id == role_id:
                        #self._trace ("Test case Uri " + tcWiUri + " already in link list for req " + reqWi.id, 2)
                        #return

        self._trace ("Creating link between requirement " + reqWi.id + " and test case Uri " + tcWiUri, 2)

        role = self.tracker.factory.create (nsTrackerTypes + "EnumOptionId")
        role.id = 'verifies'

        try:
            result = self.tracker.service.addLinkedItem(tcWiUri, reqWi._uri, role)
        except Exception as e:
            self._set_error_trace("Exception in _add_linkItem: " + str(e))

        self._trace ("Result _addLinkedItem: " + str(result), 3)

    def _clear_linkItems (self, tcWiUri):
        # Enumerates all 'verifies' linkages in test case workItem (tcWiUri = Uri of WorkItem)
        # Removes each linkage so that the workItem is clear of linkages.
        self._trace ("Clearing all links for " + tcWiUri, 2)
        role = self.tracker.factory.create (nsTrackerTypes + "EnumOptionId")
        role.id = 'verifies'
        try:
            result = self.tracker.service.getWorkItemByUri(tcWiUri)
            if len(result.linkedWorkItems) > 0:
                for linkedWorkItem in result.linkedWorkItems[0]:
                    self._trace ("linkedWorkItem: " + str(linkedWorkItem), 4)
                    result = self.tracker.service.removeLinkedItem(tcWiUri, linkedWorkItem.workItemURI, role)
        except Exception as e:
            self._set_error_trace("Exception in _clear_linkItems: " + str(e))
        self._trace ("Result _clear_linkItems: " + str(result), 3)


    def _checkExportFields(self):
        if self.settings.get('polarion_test_run_id', '') == '':
            self._set_error_trace("This Python script cannot export without a Test Run ID, please specify one.")
            return False
        if self.settings.get('project_id', '') == '':
            self._set_error_trace("This Python script cannot export without a Project ID, please specify one.")
            return False
        return True

    def start_export(self, log_path):
        # Initiate exporting requirement test data, logging status for individual
        # requirements to log_path.  Return whether the initiation was successful.

        self._trace ("Starting export", 1)

        # Check that there are Requirements and Test Cases to export.
        self._trace ("Requirements from VC to export: " + str(self.export_data), 4)
        keys = sorted(self.export_data.keys())
        if len(keys) == 0:
            self._set_error_trace("No requirements added for export")
            return False
        if len(self.tc_export_data.keys()) == 0:
            self._set_error_trace("No test cases added for export")
            return False

        # Login to Polarion and create clients to access data
        if not self._login_to_polarion():
            return False

        # Initialize transaction.
        try:
            result = self.session.service.beginTransaction()
        except Exception as e:
            self._set_error_trace("Exception in beginTransaction: " + str(e))
        self._trace ("beginTransaction() result: " + str(result), 5)

        #self.testRunID = self.firmwareUnderTest + 'Unit Test Sw Version ' + self.SwVersion

        # Get DTS.
        if appendTimeToTestRunID:
            now = time.time()
            localtime = time.localtime(now)
            stamp = time.strftime('%Y%m%d%H%M%S', localtime)
            self.testRunID = self.testRunID + '-' + stamp
            self._trace ("Date- and Time stamp added to TestRunID. New name: " + self.testRunID, 3)

        # Get a list of Polarion test runs with name testRunID.
        trQueryStr = 'project.id:' + self.projectID + ' AND id:' + self.testRunID
        self._trace ('testRun query string: ' + trQueryStr, 3)
        try:
            result = self.testManagement.service.searchTestRuns(trQueryStr, 'id')
        except Exception as e:
            self._set_error_trace("Exception in searchTestRuns: " + str(e))
        self._trace ("searchTestRun() Result" + str(result), 5)
        if result == []:
            self._trace ("No Polarion test run with name " + self.testRunID + " found. Will be created", 2)
            try:
                #MAFE: Substitute CreateTestRun with CreateTestRunWithTitle to include the package name in the test run
                #The second argument (test run ID) is left empty since Polarion will set automatically the time stamp.
                #trUri = self.testManagement.service.createTestRun(self.projectID, self.testRunID, 'Empty')
                trUri = self.testManagement.service.createTestRunWithTitle(self.projectID, '', self.testRunID, 'Empty')
                testRun = self.testManagement.service.getTestRunByUri(trUri)
            except Exception as e:
                self._set_error_trace("Exception in create/getTestRun: " + str(e))
                return False
        else:
            if len(result) == 1:
               self._trace ("Will add test records to existing Polarion test run " + result[0].id, 2)
               testRun = result[0]
            else:
                # Found more than one test run with that name. No good.
                self._trace ("Found more than one Polarion test run with name " + self.testRunID + ". Error: Name has to be unique", 1)
                for item in result:
                    self._trace ("  - " + item.id, 1)
                return False
        self._trace ("TestRun:" + str(testRun), 5)
        if len (testRun.records) == 0:
            self._trace ("No records in testRun. Create.", 3)
            newArrayOfTestRecord = self.testManagement.factory.create(nsTestManagementTypes + "ArrayOfTestRecord")
            testRun.records = newArrayOfTestRecord
            self._trace ("New TestRun with array: " + str(testRun), 4)
        
        # Get project URI.
        try:
            projectUri = self.project.service.getProject(self.projectID)
        except Exception as e:
            self._set_error_trace("Exception in getProject: " + str(e))
            endResult = self.session.service.endTransaction(False)
            return False
            
        # Get user URI.
        try:
            userUri = self.project.service.getUser(self.username)
        except Exception as e:
            self._set_error_trace("Exception in getUser: " + str(e))
            endResult = self.session.service.endTransaction(False)
            return False
        self._trace ("user Uri: " + str(userUri), 3)
        emptyWorkItem = self.tracker.factory.create(nsTrackerTypes + "WorkItem")

        # Loop through all testcases.
        for dic_test_case_curr in self.tc_export_data.values():
            tcUri = ""
            testNameTitle = ""
            currTestName = dic_test_case_curr["test_name"]
            currEnvName = dic_test_case_curr["environment_name"]
            currTestStatus = dic_test_case_curr["test_status"]
            dic_req_links = dic_test_case_curr["test_req_keys"]
            self._trace ("Computing test case " + currEnvName + ':' + currTestName + ':' + currTestStatus, 3)

            # Prepend environment
            if self.prependEnvToTestCaseName:
                testNameTitle = currEnvName + ':' + currTestName
            else:
                testNameTitle = currTestName
            self._trace ("Test case name for Polarion update:" + str (testNameTitle), 3)

            # Get Polarion work item ID from tescase name.
            # Create testcase in Polarion if unavailable
            tcQueryStrg = 'project.id:' + self.projectID + ' AND title:"' + testNameTitle + '" AND type:' + self.testCaseType
            self._trace ("Query String to get test case ID from Polarion: " + str(tcQueryStrg), 3)
            try:
                qResult = self.tracker.service.queryWorkItems(tcQueryStrg, 'id', 'id')
            except Exception as e:
                self._set_error_trace("Exception in queryWorkItems: " + str(e))
                endResult = self.session.service.endTransaction(False)
                return False
                
            # Get tcUri by find or create.
            self._trace ("Query-Result: " + str(qResult), 4)
            if qResult == []:
                # Test case not found in Polarion => create it
                self._trace ("Test case not found in Polarion. Will create it", 1)

                newWI = emptyWorkItem
                newWI.project = projectUri
                newWI.type.id = self.testCaseType
                newWI.title = testNameTitle
                self._trace ("newWI: " + str(newWI), 4)

                try:
                    tcUri = self.tracker.service.createWorkItem(newWI)
                    self._trace ("Test case successfully created. Result: " + str(tcUri), 1)
                except Exception as e:
                    self._set_error_trace("Exception in createWorkItem: " + str(e))
                    endResult = self.session.service.endTransaction(False)
                    return False
            else:
                # We found the testcase. Should only be one!
                if len(qResult) == 1:
                    tcUri = qResult[0]._uri
                    self._trace ("One testcase found. Uri:" + tcUri, 1)
                else:
                    self._set_error_trace("More than one testcases found for query " + str(tcQueryStrg))
                    self._trace ("Query-result: " + str(qResult), 1)
                    endResult = self.session.service.endTransaction(False)
                    return False

            # We found or created one test case. Now we need to add the test case to the test run
            self._add_testRecord (testRun._uri, tcUri, currTestStatus, userUri)

            # First, clear down all requirements links from the Test Case.
            self._clear_linkItems(tcUri)
            # Process requirements links for the Test Case.
            for curr_link in dic_req_links.values():
                wiID = curr_link["req_id"]
                # Get requirements WorkItem from Polarion. No problem for this script if unavailable
                # but user might want to manually eliminate this requirement from VC environment
                self._trace ("Getting requirement WorkItem from Polarion", 3)
                try:
                    reqWi = self.tracker.service.getWorkItemById(self.projectID, wiID)
                except Exception as e:
                    self._set_error_trace("Exception in getWorkItemById: " + str(e))
                    endResult = self.session.service.endTransaction(False)
                    return False

                self._trace ("Result: " + str(reqWi), 4)
                if reqWi._unresolvable:
                    self._trace ("Requirement WorkItem " + wiID + " not found in Polarion. Links to test cases will not be updated.", 1)
                else:
                    self._trace ("Requirement WorkItem " + wiID + " found. Links to test cases will be updated.", 3)
                        
                # Update the linkage to the requirement (verifies/is verified by)
                self._add_linkItem (reqWi, tcUri)

        result = self.session.service.endTransaction(False)  #False = no rollback

        # Mark all requirements as beeing exported
        log_file = open(log_path, 'wb')
        for k in keys:
            req_data = self.export_data[ k ]
            #log_file.write( req_data.get('key','') + '\tOK\n' )
        log_file.close()
        self.export_data = {}

        return True

        
    def finish_export(self):
        # Finish exporting requirement test data.  Return whether the export
        # process completed normally.  (Data for individual requirements may not
        # have been successfully exported even if this method returns True.  The
        # log_path specified to start_export should record status for each
        # requirement.)

        self._logout_from_polarion()
        return True
